buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  bus_route
  remaining_bus_route
  on_route
  br_start
  br_stop
  path_to_start_route
  
  bus_current_capacity
]
 
globals [graph bus-routes-graph predef_bus_routes]

to init-buses
  ; Initialize your agents here.  
  set bus_current_capacity 0
  
  ; List of predefined bus routes
  set predef_bus_routes [[3 16 11 1 19] [6 8 9 3 4 5 17 7 1 19] [2 8 9 20 12 15 18] [18 15 0 14 23 19] [3 4 10 13 23 19] [3 20 21 22 0] [18 15 12 22 13 10 5 16]]
  
  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
  
  ; This list contains the topology of the entire network of bus routes. 
  ; The variable 'bus-routes-graph' contains the edge between X and Y only if there is a route that goes from X to Y (if there is not such route, even if there is a road between X and Y, the 'bus-routes-graph' does not contrain it)
  set bus-routes-graph create-graph-from-bus-routes predef_bus_routes
  
  ; Initialise bus route
  let max_pass 0
  
;  foreach predef_bus_routes [
;    let x count-passengers-on-route ?
;    
;    if max_pass < x [
;      set max_pass x
;      set bus_route ?
;    ]
;    add-bus 1
    

;  ]
  
  if bus_route = 0 [
    set bus_route [3 16 11 1 19]
  ]
  
  
  let internal_b_id ((bus_id - 24) mod (length predef_bus_routes))
  setup-bus-route item internal_b_id predef_bus_routes false
  
  setup-bus-route bus_route false
  
  set on_route false
  set path_to_start_route []
  
end

to setup-bus-route [given_route reversed]
  ifelse reversed
  [ set bus_route reverse given_route ]
  [ set bus_route given_route ]
  set br_start first bus_route
  set br_stop last bus_route
  set remaining_bus_route bus_route
  show (word "New route:" bus_route)
end

to execute-actions
  ; Add decision making strategies for your agents here.
  ; You are allowed to use the global variable 'ticks'.
  
  if count buses < length predef_bus_routes [
    add-bus 1
  ]
  
  ; Check whether we are at the start of the bus route
  if current_stop = br_start and not on_route [
    set on_route true
    set path_to_start_route []
  ]
  
  ifelse not on_route
  [
;     If bus is not on route, search for path to the starting point of the route and move there
    if path_to_start_route = [] [
      set path_to_start_route (get-shortest-path current_stop first remaining_bus_route)
    ]
    
    if current_stop = first path_to_start_route [
      set path_to_start_route remove-item 0 path_to_start_route
    ]
    
    travel-to first path_to_start_route
  ]
  [
    if count-passengers-on-route bus_route != 0 or length bus_passengers != 0 [
      ;     If bus is at the end of the route, reverse the route
      if current_stop = br_stop [
        setup-bus-route bus_route true
      ]
      
      if is-number? current_stop and current_stop != -1 [
        
        ;       Drop off passengers at current stop
        foreach bus_passengers [
          if not can-transport-one-station current_stop item 1 ? bus_route [
            show ( word "Dropped passenger" ?)
            drop-off-passenger item 0 ?
            set bus_current_capacity length bus_passengers
          ]
        ]
        
        ;       Pick up passengers that travel on the bus route
        let passengers_at_current_stop get-passengers-at-stop current_stop
        if length passengers_at_current_stop != 0 [        
          foreach passengers_at_current_stop [
            if can-transport-one-station current_stop item 1 ? bus_route [
              show ( word "Picked passenger " ? )
              pick-up-passenger item 0 ?
              set bus_current_capacity length bus_passengers
            ]
          ]
        ]
                
      ]
      
      if current_stop = first remaining_bus_route [
        set remaining_bus_route remove-item 0 remaining_bus_route
      ]
      
      travel-to first remaining_bus_route
    ]
  ]
end


to-report count-passengers-on-route [route]
  let counter 0
  foreach route [
    let current-station ?
    let stop_pass_list filter [can-transport-one-station current-station (item 1 ?) route] get-passengers-at-stop current-station
    set counter counter + length stop_pass_list
  ]
  report counter
end


to-report can-transport-one-station [passnger-position passenger-destination bus-route ]
  ifelse length bus-route > 1 and passnger-position != passenger-destination  [
    let next-station item 0 (get-shortest-path passnger-position passenger-destination)
    let index 1
    while [index < (length bus-route)]
    [
      if item (index - 1) bus-route = passnger-position and (item index bus-route) = next-station [
        report true
      ]
      set index (index + 1)
    ]
    report false
  ]
  [
    show "Bus route has only one element!"
    report false
  ]
  
end

to-report create-graph-from-bus-routes [bus-routes]
  let new-graph [[] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] []]
  foreach bus-routes [
    let index 1
    let route ?
    while [index < (length route)]
    [
      let x item index route
      let y item (index - 1) route
      
       set new-graph (replace-item x new-graph (lput y (item x new-graph)))
       set new-graph (replace-item y new-graph (lput x (item y new-graph)))
      
      set index (index + 1)
    ]
  ]
  
  foreach new-graph [
    set ? remove-duplicates ?
  ]
  report new-graph
end



to-report get-shortest-path [source target]
;  [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]
  let Q [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]
  let dist n-values 24 [1000000000000]
  let prev n-values 24 [-1000]
  
  set dist (replace-item source dist 0)
  
  while [length Q != 0]
  [
    let u 0
    let min_val 1000000000000
    foreach Q [
      if item ? dist < min_val [
        set min_val item ? dist
        set u ?
      ]
    ]
 
    set Q remove u Q
    foreach (item u bus-routes-graph) [
      let alt (item u dist + get-distance u ?)
      if alt < item ? dist [
        set dist (replace-item ? dist alt)
        set prev (replace-item ? prev u)
      ]
    ]
  ]
  
  let S []
  let u target
  while [item u prev >= 0]
  [
    set S fput u S
    set u (item u prev)
  ]
;  set S fput u S   ;not needed to put the source node in path
  report S
end